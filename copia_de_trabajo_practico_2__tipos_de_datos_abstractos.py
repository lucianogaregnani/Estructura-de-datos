# -*- coding: utf-8 -*-
"""Copia de Trabajo practico 2_ Tipos de datos Abstractos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/13RDZqkjn5C46DuKOXS3YvXwYEXEDnhl6

# ![alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/50px-Python-logo-notext.svg.png) **Trabajo Práctico 2: Tipos de datos abstractos** ![alt text](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c3/Python-logo-notext.svg/50px-Python-logo-notext.svg.png)

En este trabajo práctico, vamos a trabajar con la definición de tipos de datos abstractos en Python. Recuerden crear una copia de este archivo en su ***Google Drive*** para tener permisos de edición.

### Sergio: **sergio.gonzalez@unahur.edu.ar** ###
### Martin: **martin.pustilnik@unahur.edu.ar** ###

**En cada ejercicio, luego de implementar el TDA pedido, tienen que probar cada una de las operaciones en un programa principal, ejecutando cada una de ellas**

**En el video les comenté de la función \_\_str__ para la representación de variables de los TDAs, en lugar de \_\_str__ pueden implementar \_\_repr__ que es similar pero más general (No solo sirve para el *print*, sino para la representación en general de variables del TDA)**

### **Ejercicio 1**

Implementar el TDA "Propiedad" que modela un inmueble, con una estructura definida por los siguientes componentes:
- Calle
- Número
- Localidad
- Año de construcción
- Cantidad de ambientes

Implementar las siguientes operaciones:
- Constructor: Debe incluir las validaciones necesarias, teniendo en cuenta que solo se almacenan propiedades construidas luego de 1870.
- \_\_repr__: Al usar la función *print* con una variable del tipo propiedad debe mostrar: **'calle' 'numero' ('localidad')**.
- mismaLocalidad: Operación que recibe dos propiedades y retorna *True* si estan en la misma localidad y *False* en caso contrario.
- mayorNumeración: Operación que recibe dos propiedades y si están en la misma calle, retorna la que posee mayor numeración. Si están calles diferentes debe lanzar una excepción.
- calculaImpuestoARBA: Operación que retorna el porcentaje de impuesto inmobiliario de una propiedad, según la siguiente regla:
 - Propiedades entre 1870 y 1949:
   - Entre 1 y 3 ambientes: 5% de impuesto
   - Entre 4 y 6 ambientes: 10% de impuesto
   - Más de 6 ambientes: 25 % de impuesto
 - Propiedades desde 1950 hasta la actualidad:
   - Entre 1 y 5 ambientes: 5% de impuesto
   - Más de 5 ambientes: 35 % de impuesto
"""

# def validadTipo(variable,)

def mayorEntre_Y_(num1, num2):
  if num1 >= num2:
    numeroMayor = num1
  else:
    numeroMayor = num2
  return numeroMayor


class Propiedad:
  def __init__(self, calle = "", número = 0, localidad = "", añoDeConstrucción = 0, cantidadDeAmbientes = 0):
    self.calle = calle
    self.número = número
    self.localidad = localidad
    if añoDeConstrucción >= 1870: 
      self.añoDeConstrucción = añoDeConstrucción
    else:
      raise Exception("El año de construcción debe ser a partir de 1870")
    self.cantidadDeAmbientes = cantidadDeAmbientes
  def __repr__(self):
    propiedad = self.calle + " " + str(self.número) + "(" + self.localidad + ")"
    return propiedad
  def mismaLocalidad(pro1, pro2):
    return pro1.localidad == pro2.localidad 
  def mayorNumeración(pro1, pro2):
    if pro1.calle == pro2.calle:
      mayorNumeracion = mayorEntre_Y_(pro1.número, pro2.número)
      return mayorNumeracion
    else:
      raise Exception("Las calles deben ser iguales.")
  def calculaImpuestoARBA(self):
    if (self.añoDeConstrucción >= 1870 and self.añoDeConstrucción <= 1949) and (self.cantidadDeAmbientes >= 1 and self.cantidadDeAmbientes <= 3):
      impuesto = 5
    elif (self.añoDeConstrucción >= 1870 and self.añoDeConstrucción <= 1949) and (self.cantidadDeAmbientes >= 4 and self.cantidadDeAmbientes <= 6):
      impuesto = 10
    elif (self.añoDeConstrucción >= 1870 and self.añoDeConstrucción <= 1949) and self.cantidadDeAmbientes > 6:
      impuesto = 25
    elif (self.añoDeConstrucción > 1949) and (self.cantidadDeAmbientes >= 1 and self.cantidadDeAmbientes <= 5):
      impuesto = 5
    elif (self.añoDeConstrucción > 1949) and (self.cantidadDeAmbientes > 5):
      impuesto = 35
    return impuesto



  
pro1 = Propiedad("Malaspina", 3464, "Hurlingham", 1870, 2) 
pro2 = Propiedad("Malaspina", 233, "HADJ", 2122, 4)

print(pro1.calculaImpuestoARBA())

"""### **Ejercicio 2**

Implementar el TDA "Quiniela" que modela un juego de quiniela con dos números premiados. La estructura contiene:
- Primer número premiado
- Segundo número premiado
- Multiplicador (cuánto se paga por cada peso apostado)

Implementar las siguientes operaciones:
- Constructor: Debe incluir las validaciones necesarias, teniendo en cuenta que los números que participan se encuentran entre 0 y 999.
- \_\_repr__: Al usar la función *print* con una variable del tipo quiniela debe mostrar: **Primer número ganador: 'numero' - Segundo número ganador: 'numero' - Paga: 'multiplicador'X**.
- esNumeroGanador: Operación que recibe un número por parámetros y retorna *True* si el número resultó ganador o *False* en caso contrario.
- importeAPagar: Operación que recibe un número y el monto apostado por parámetros y retorna el importe a pagar si la apuesta es ganadora o 0 en caso contrario. Si el número es el primer premio, se paga 'mutiplicador' por cada peso apostado, si es el segundo premio se paga la mitad. Solo se aceptan apuestas hasta $1000.
- premiadosCercanos: Operación que retorna *True* si los números premiados están a menos de 10 números de distancia y *False* en caso contrario. 



"""

class Quiniela:
  def __init__ (self, primerNumeroPremiado, segundoNumeroPremiado, multiplicador):
    if (primerNumeroPremiado >= 0 and primerNumeroPremiado <= 999) and (segundoNumeroPremiado >= 0 and segundoNumeroPremiado <= 999): 
      self.primerNumeroPremiado = primerNumeroPremiado
      self.segundoNumeroPremiado = segundoNumeroPremiado
    self.multiplicador = multiplicador 
  def __repr__(self):
    return "Primer número ganador: " + str(self.primerNumeroPremiado) + " - " + "Segundo número ganador: " + str(self.segundoNumeroPremiado) + " - " + "Paga: " + str(self.multiplicador)
  def esNumeroGanador(self, numero):
    if (numero == self.primerNumeroPremiado) or (numero == self.segundoNumeroPremiado):
      esGanador = True 
    else:
      esGanador = False
    return esGanador
  def importeAPagar(self, numero, apuesta):
    if self.esNumeroGanador(numero) and (numero == self.primerNumeroPremiado) and (apuesta <= 1000):
      importeAPagar = apuesta * self.multiplicador
    elif self.esNumeroGanador(numero) and (numero == self.segundoNumeroPremiado) and (apuesta <= 1000):
      importeAPagar = (apuesta * self.multiplicador) // 2
    else: 
      importeAPagar = 0
    return importeAPagar
  def premiadosCercanos(self):
    if abs(self.primerNumeroPremiado - self.segundoNumeroPremiado) < 10:
      esPremioCercano = True
    else:
      esPremioCercano = False
    return esPremioCercano

quiniela1 = Quiniela(1, 10, 2)

print(quiniela1.premiadosCercanos())

"""### **Ejercicio 3**

Implementar el TDA "Cuenta" que modela una cuenta bancaria, la estructura de datos esta compuesta por los siguientes componentes:
- Número de cuenta
- DNI del titular
- Saldo de cuenta actual
- Interés anual

Implementar las siguientes operaciones:
- Constructor: Debe incluir las validaciones necesarias.
- \_\_repr__: Al usar la función *print* con una variable del tipo cuenta debe mostrar: **Cuenta Nro: 'numero' - Titular: 'dni' ($'saldo')**.
- actualizarSaldo: Operación que actualiza el saldo de la cuenta aplicándole el interés diario (interés anual dividido entre 365).
- ingresarDinero: Operación que recibe un número e ingresa esa cantidad en la cuenta.
- retirarDinero: Operación que recibe un número y extrae esa cantidad de la cuenta (si hay saldo disponible), sino debe lanzar una excepción.
"""

def validarTipo(variable, nombre, tipo):
    if isinstance(variable, tipo):
        return variable
    else:
        raise Exception("La variable " + nombre + " debe ser de tipo " + str(tipo) + ".")

class Cuenta:
  def __init__(self, numeroDeCuenta = 0, dni = 0, saldoDeCuenta = 0, interesAnual = 0):
    self.numeroDeCuenta = validarTipo(numeroDeCuenta, "numeroDeCuenta" , int)
    self.dni = validarTipo(dni, "dni", int)
    self.saldoDeCuenta = validarTipo(saldoDeCuenta, "saldoDeCuenta", int)
    self.interesAnual = validarTipo(interesAnual, "interesAnual", float)
  def __repr__(self):
    return "Cuenta Nro: " + str(self.numeroDeCuenta) + " - " + "Titular: " + str(self.dni) + "(" + str(self.saldoDeCuenta) + ")"
  def actualizarSaldo(self):
    self.saldoDeCuenta += self.interesAnual // 365
    return self.saldoDeCuenta
  def ingresarDinero(self, numero):
    self.saldoDeCuenta += numero
    return self.saldoDeCuenta
  def retirarDinero(self, numero):
    if self.saldoDeCuenta >= numero:
      self.saldoDeCuenta -= numero
      return self.saldoDeCuenta
    else:
      raise Exception("No puede retirar " + str(numero) + " pesos de su cuenta, su saldo es de: " + str(self.saldoDeCuenta))
cuenta1 = Cuenta(23, 4433223, 23, 200.0)

print(cuenta1.retirarDinero(22))

"""### **Ejercicio 4**

Implementar el TDA "Tiempo" que modela una duracion en horas, minutos y segundos.

Se deben implementar las siguientes operaciones:
- Constructor: Debe incluir las validaciones necesarias, la hora debe ser un número positivo y los minutos y segundos deben ser números positivos entre 0 y 59.
- \_\_repr__: Al usar la función *print* con una variable del tipo tiempo debe mostrar: **'horas':'minutos':'segundos'**.
- tiempoASegundos: Operación que toma una variable de tipo tiempo y retorna la cantidad en segundos.
- tiemposDesdeSegundos: Operación que recibe un tiempo en segundos como parámetro y retorna una variable de tipo tiempo, en horas minutos y segundos. 
- mayorDuracion: Operación que recibe dos variables de tipo tiempo y retorna la de mayor duración.
"""

def validarHora(numero):
  if 0 <= numero <= 23:
    return numero
  else:
    raise Exception(str(numero) + " debe ser un número positivo")

def validarSegundosOMinutos(numero):
  if 0 <= numero <= 59:
    return numero
  else:
    raise Exception(str(numero) + " Debe ser un número entre 0 y 59")

def pasarHoraMinutosYSegundosASegundos(hora, minuto, segundo):
  horaASegundos = (hora * 60) * 60
  minutoASegundos = minuto * 60
  segundosTotales = horaASegundos + minutoASegundos + segundo
  return segundosTotales

class Tiempo:
  def __init__(self, horas = 0, minutos = 0, segundos = 0):
    self.horas = validarHora(horas)
    self.minutos = validarSegundosOMinutos(minutos)
    self.segundos = validarSegundosOMinutos(segundos)
  def __repr__(self):
    return "'" + str(self.horas) + "'" + ":" + "'" + str(self.minutos) + "'" + ":" + "'" + str(self.segundos) + "'"
  def tiempoASegundos(self):
    return pasarHoraMinutosYSegundosASegundos(self.horas, self.minutos, self.segundos)
  def tiemposDesdeSegundos(self, segundosAConvertir):
    segundosCalculo = segundosAConvertir // 60
    segundos = segundosAConvertir % 60
    minutosCalculo = segundosCalculo // 60
    minutos = segundosCalculo % 60
    horas = minutosCalculo
    tiempo = Tiempo(horas, minutos, segundos)
    return tiempo
  def mayorDuracion(tiempo1, tiempo2):
    if tiempo1.tiempoASegundos() > tiempo2.tiempoASegundos():
      mayorDuracion = tiempo1
    elif tiempo1.tiempoASegundos() < tiempo2.tiempoASegundos():
      mayorDuracion = tiempo2
    else:
      raise Exception("Los tiempos son iguales")
    return mayorDuracion



tiempo1 = Tiempo(23, 23, 32)
tiempo2 = Tiempo(23, 24, 32)

print(tiempo1.mayorDuracion(tiempo2))

"""### **Ejercicio 5**

Las plataformas de música online como ***YouTube*** y ***Spotify*** almacenan la información asociada a las canciones en estructuras de datos complejas para hacer las búsquedas de manera eficiente. Para esto se deben modelar las canciones. Implementar el TDA "Cancion" con los siguientes componentes:
- Nombre
- Artista
- Duración
- Género musical (6 posibles: Rock, Jazz, Blues, Funk, Reggae y Rap).
- Año de edición
- Número de likes

Implementar las siguientes operaciones:
- Constructor: Debe incluir las validaciones necesarias.
- \_\_repr__: Al usar la función *print* con una variable del tipo canción debe mostrar: **'nombre' - 'artista' ('duracion')**.
- mayorDuracion: Operación que recibe dos canciones por parámetros y retorna la de mayor duración.
- agregaLikes: Operación que recibe un número e incrementa la cantidad de likes de la canción en ese número.
- masVotada: Operacion que recibe dos canciones y sin son del mismo artista y del mismo género musical, retorna la que tiene mayor cantidad de likes. En caso contrario debe lanzar una excepción.
"""

def validarGeneroMusical(genero):
  if esGeneroValido(genero):
    return genero
  else:
    raise Exception(genero + " No es un genero valido")

def esGeneroValido(genero):
  return genero.lower() == "rock" or genero.lower() == "jazz" or genero.lower() == "blues" or genero.lower() == "funk" or genero.lower() == "reggae" or genero.lower() == "rap"  

class Cancion:
  def __init__(self, nombre = "", artista = "", duracion = 0, generoMusical = "", añoDeEdicion = 0, numeroDeLikes = 0):
    self.nombre = validarTipo(nombre, "nombre" , str)
    self.artista = validarTipo(artista, "artista", str)
    self.duracion = validarTipo(duracion, "duracion", int)
    self.generoMusical = validarGeneroMusical(generoMusical) 
    self.añoDeEdicion = validarTipo(añoDeEdicion, "añoDeEdicion", int)
    self.numeroDeLikes = validarTipo(numeroDeLikes, "numeroDeLikes", int)

  def __repr__(self):
    return "'" + self.nombre + "'" + " - " + "'" + self.artista + "'" + "('" + str(self.duracion) + "')."

  def mayorDuracion(cancion1, cancion2):
    if cancion1.duracion > cancion2.duracion:
      mayorDuracion = cancion1
    elif cancion1.duracion < cancion2.duracion:
      mayorDuracion = cancion2
    else:
      mayorDuracion = "Tienen la misma duracion"
    return str(mayorDuracion) + " tiene mayor duracion" 

  def agregaLikes(self, numero):
    self.numeroDeLikes += numero
    return self.numeroDeLikes

  def masVotada(self, cancion2):
    if self.sonArtistasIguales(cancion2) and self.sonGenerosIguales(cancion2):
      return self.cancionConMasLikes(cancion2)
    else:
      raise Exception("Las canciones deben tener el mismo autor y el mismo genero")

  def cancionConMasLikes(cancion1, cancion2):
    if cancion1.numeroDeLikes > cancion2.numeroDeLikes:
      cancionConMasLikes = cancion1
    elif cancion1.numeroDeLikes < cancion2.numeroDeLikes:
      cancionConMasLikes = cancion2
    else:
      cancionConMasLikes = "Tienen la misma cantidad de likes"
    return cancionConMasLikes

  def sonArtistasIguales(cancion1, cancion2):
    return cancion1.artista.lower() == cancion2.artista.lower()

  def sonGenerosIguales(cancion1, cancion2):
    return cancion1.generoMusical == cancion2.generoMusical
  

cancion1 = Cancion("Eclipse", "lit Killah", 3, "Rap", 2021, 528066)
cancion2 = Cancion("Mala mia", "Lit Killah", 4, "Rap", 2021, 528065)

print(cancion1.masVotada(cancion2))